<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Node面试总结1 | 规矩之内,皆是自由</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node面试总结1</h1><a id="logo" href="/.">规矩之内,皆是自由</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Node面试总结1</h1><div class="post-meta">Mar 1, 2020<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h5 id="1、尾递归"><a href="#1、尾递归" class="headerlink" title="1、尾递归"></a>1、尾递归</h5><blockquote>
<p>定义：如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。</p>
<p>原理：当<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">facttail</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*Compute a factorialina tail - recursive manner.*/</span>  </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> facttail(n - <span class="number">1</span>, n * a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><h5 id="1、Node-浏览器的EventLoop"><a href="#1、Node-浏览器的EventLoop" class="headerlink" title="1、Node/浏览器的EventLoop"></a>1、Node/浏览器的EventLoop</h5><h5 id="2、对restful的理解"><a href="#2、对restful的理解" class="headerlink" title="2、对restful的理解"></a>2、对restful的理解</h5><blockquote>
<p>看url就知道要什么<br>看http method就知道干什么<br>看http status code就知道结果 如何</p>
</blockquote>
<p>restful面向资源的，像下面这种就是面向user这个资源的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get &#x2F;users&#x2F;&#123;userId&#125;  获取userId对应的user信息</span><br><span class="line">post &#x2F;users 创建一个新的user</span><br><span class="line">put &#x2F;users&#x2F;&#123;userId&#125; 更改userId对应的user信息</span><br><span class="line">delete &#x2F;users&#x2F;&#123;userId&#125; 删除userId对应的user。</span><br></pre></td></tr></table></figure>

<p>soap是买你想管理员用户的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post &#x2F;users&#x2F;getUser</span><br><span class="line">post &#x2F;users&#x2F;creatUser</span><br><span class="line">post &#x2F;users&#x2F;updateUser</span><br><span class="line">post &#x2F;users&#x2F;deleteUser</span><br></pre></td></tr></table></figure>



<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h5 id="1、tcp-的握手协议"><a href="#1、tcp-的握手协议" class="headerlink" title="1、tcp 的握手协议"></a>1、tcp 的握手协议</h5><p><a href="https://blog.csdn.net/qq_32998153/article/details/79680704" target="_blank" rel="noopener">https://blog.csdn.net/qq_32998153/article/details/79680704</a></p>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<p>建立连接的三次握手、断开连接的四次握手</p>
<p><strong>三次握手</strong></p>
<img src="/2020/03/01/Node%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/1583480263292.jpg" alt="1583480263292" style="zoom:50%;">

<p><strong>四次挥手</strong></p>
<img src="/2020/03/01/Node%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/1583480189873.jpg" alt="1583480189873" style="zoom:50%;">

<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<h5 id="2、websock协议"><a href="#2、websock协议" class="headerlink" title="2、websock协议"></a>2、websock协议</h5><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h5 id="1、redis是什么？"><a href="#1、redis是什么？" class="headerlink" title="1、redis是什么？"></a>1、redis是什么？</h5><p>Redis 是一个内存数据库，性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。<strong>单进程单线程</strong>，是线程安全的，采用 <strong>IO 多路复用机制</strong>。丰富的数据类型，支持<strong>字符串（strings）、散列（hashes）、列表（lists）、无序集合（sets）、有序集合（sorted sets）等</strong>。支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载。主从复制，哨兵，高可用。可以用作分布式锁。可以作为消息中间件使用，支持发布订阅。</p>
<h5 id="2、redis的hash-amp-amp-rehash"><a href="#2、redis的hash-amp-amp-rehash" class="headerlink" title="2、redis的hash &amp;&amp; rehash"></a>2、redis的hash &amp;&amp; rehash</h5><img src="/2020/03/01/Node%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/1583329716784.jpg" alt="1583329716784" style="zoom:50%;">

<p>hash底层使用字典实现，字典的底层通过hash表实现，类似于Java中HashMap。</p>
<ul>
<li>dict：字典，存储2个dictht，一般只会用dict[0]，dict[1]只会在rehash并且dict[0].table不为null的场景才会使用</li>
<li>dictht：hash表</li>
<li>dictEntry：类似于HashMap的结构，通过next解决hash冲突</li>
<li>Cluster模式下，一个redisdb对应一个dic</li>
</ul>
<p>扩容：当 hash 表中元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是原数组大小的 2 倍。不过如果 Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容 (dict_can_resize)，但是如果 hash 表已经非常满了，元素的个数已经达到了第一维数组长度的 5 倍 (dict_force_resize_ratio)，说明 hash 表已经过于拥挤了，这个时候就会强制扩容。</p>
<blockquote>
<p>bgsave: redis fork 一个子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</p>
</blockquote>
<p>缩容：当 hash 表因为元素的逐渐删除变得越来越稀疏时，，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。缩容的条件是元素个数低于数组长度的 10%。<strong>缩容不会考虑 Redis 是否正在做 bgsave</strong>。</p>
<h5 id="3、redis中主从复制、cluster和sentinel"><a href="#3、redis中主从复制、cluster和sentinel" class="headerlink" title="3、redis中主从复制、cluster和sentinel"></a>3、redis中主从复制、cluster和sentinel</h5><p><strong>主从复制</strong></p>
<p>这是实现sentinel和clustter的基石，实现读写分离、负载均衡等。</p>
<p>缺点：master单点问题</p>
<p><strong>sentinel</strong></p>
<p>redis官方推荐使用的一个HA方案。sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。在主从复制的基础上增加以下功能</p>
<ul>
<li><p>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p>
</li>
<li><p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
</li>
<li><p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</p>
</li>
</ul>
<p>缺点：依然只有一个master，单个master有瓶颈。</p>
<p>cluster：主要针对于海量数据</p>
<p>Redis Cluster 把所有的数据划分为16384个不同的槽位</p>
<ul>
<li>无中心节点</li>
<li>数据按照Slot存储分布在多个Redis实例上</li>
<li>平滑的进行扩容/缩容节点</li>
<li>自动故障转移(节点之间通过Gossip协议交换状态信息,进行投票机制完成Slave到Master角色的提升)</li>
<li>降低运维成本，提高了系统的可扩展性和高可用性</li>
</ul>
<p>redis cluster <strong>vs</strong> replication + sentinel</p>
<p>如果数据量很大建议使用cluster、如果不是很大，可以使用sentinel搭建一个集群保证高可用性即可。</p>
<h5 id="4、hash、一致性hash和hash-slot算法"><a href="#4、hash、一致性hash和hash-slot算法" class="headerlink" title="4、hash、一致性hash和hash slot算法"></a>4、hash、一致性hash和hash slot算法</h5><p><strong>hash</strong></p>
<p>先计算出一个hash值，然后使用 CRC余数算法将hash值和机器数mod后取余数，机器的编号可以是0到N-1(N是机器数)，计算出的结果一一对应即可。</p>
<p>缺点：当一个机器挂了之后，那么就需要在计算缓存过程中将这台服务器去掉，即N台服务器，目前就只有N-1台提供缓存服务，此时需要一个rehash过程，而reash得到的结果将导致正常的用户请求不能找到原来缓存数据的正确机器，其他N-1台服务器上的缓存数据将大量失效，此时所有的用户请求全部会集中到数据库上，严重可能导致整个生产环境挂掉.</p>
<p><strong>一致性hash</strong></p>
<img src="/2020/03/01/Node%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/1583461313835.jpg" alt="1583461313835" style="zoom:50%;">

<p>一致性hash：在移除/添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。主要有三步：</p>
<ol>
<li>环形空间</li>
<li>将数据通过hash算法处理后映射到环上</li>
<li>将机器通过hash算法处理后映射到环上</li>
</ol>
<p>一致性hash为了保证平衡性，提出了<strong>虚拟节点</strong>的概念。</p>
<blockquote>
<p>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（replica），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。即把想象在这个环上有很多“虚拟节点”，数据的存储是沿着环的顺时针方向找一个虚拟节点，每个虚拟节点都会关联到一个真实节点。</p>
</blockquote>
<p><strong>hash slot</strong></p>
<p>redis cluster 有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。每个节点负责维护一部分槽以及槽所映射的键值数据。</p>
<p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0~16383 整数槽内，计算公式：slot = CRC16（key）&amp; 16384。</p>
<blockquote>
<p>缓存的key hash结果是和slot绑定的，而不是和服务器节点绑定，所以节点的更替只需要迁移slot即可平滑过渡。</p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h6 id="1、sql优化"><a href="#1、sql优化" class="headerlink" title="1、sql优化"></a>1、sql优化</h6><ol>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<code>select id from t where num is null</code></li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描 如：<code>select id from t where num=10 or num=20</code> 可以这样查询：<code>select id from t where num=10
union all
select id from t where num=20</code></li>
</ol>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h5 id="1、如何保证接口幂等性"><a href="#1、如何保证接口幂等性" class="headerlink" title="1、如何保证接口幂等性"></a>1、如何保证接口幂等性</h5><p>部分接口天生就能够保证幂等性，例如查询，统计等。</p>
<ol>
<li>全局唯一ID（根据业务的操作和内容生成一个唯一ID存储在缓存中，在执行该操作前先判断是否存在该ID）</li>
<li>去重表（用于在业务中有唯一标识的插入场景中）</li>
<li>多版本控制（用于更新的场景中）</li>
<li>状态机控制（用于有状态流转，例如：订单创建、订单付款成功、订单付款失败等）</li>
</ol>
<h5 id="2、悲观锁和乐观锁"><a href="#2、悲观锁和乐观锁" class="headerlink" title="2、悲观锁和乐观锁"></a>2、悲观锁和乐观锁</h5><p><strong>悲观锁</strong></p>
<blockquote>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
</blockquote>
<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>
<p><strong>乐观锁</strong></p>
<blockquote>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>
</blockquote>
<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式大大的提高了数据操作的性能;</p>
<h5 id="3、如何设计秒杀系统"><a href="#3、如何设计秒杀系统" class="headerlink" title="3、如何设计秒杀系统"></a>3、如何设计秒杀系统</h5><p>特点：</p>
<ul>
<li>某一时刻突然涌入大量请求</li>
<li>读请求 &gt;&gt; 写请求，写请求 &gt;&gt; 数据库item数量</li>
</ul>
<p>大体思路是：1）尽量将请求拦截在系统上游；2）读多写少的场景多用缓存</p>
<ol>
<li>浏览器端。<ol>
<li>浏览器点击查询之后将按钮置灰（产品层面）；</li>
<li>js设置n秒之内只能提交一次请求</li>
</ol>
</li>
<li>站点层。页面缓存。<ol>
<li>对同一个用户的请求设置其访问频率，n秒内到达的请求返回同一个页面</li>
<li>对同一个item的查询设置其访问频率，n秒内到达的请求返回同一个页面</li>
</ol>
</li>
<li>服务层。<ol>
<li>对于写请求，进入消息队列，每次只透有限的请求到数据库</li>
<li>对于读请求，使用cache抗<ol>
<li>注意：使用缓存可能会出现缓存穿透、缓存击穿、缓存雪崩问题，这些都需要考虑</li>
</ol>
</li>
</ol>
</li>
<li>dao层。到了这一层基本上没什么请求了</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/03/05/MFS-%E5%85%A5%E9%97%A8/">MFS-入门</a><a class="next" href="/2020/02/29/%E6%B5%85%E8%B0%88NodeJS/">浅谈NodeJS</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJS/">NodeJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dev-ops/">dev&ops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lvs/">lvs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 15px;">内核</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/%E5%B8%83%E5%B1%80/" style="font-size: 15px;">布局</a> <a href="/tags/js-%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 15px;">js - 作用域</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">微信小程序</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 15px;">数组</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/03/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8/">小程序入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/29/flex%E5%B8%83%E5%B1%80/">flex布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/">数据结构与算法-稀疏数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/js%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">js中的单例模式-装饰模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/js%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">js中的设计模式-代理模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/js%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">js中的设计模式-策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/js%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">js中的设计模式-单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/js%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">js中的设计模式-观察者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4/">每日一个Linux命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/21/ts%E9%87%8D%E9%9A%BE%E7%82%B9%E6%A2%B3%E7%90%86/">ts重难点梳理</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>