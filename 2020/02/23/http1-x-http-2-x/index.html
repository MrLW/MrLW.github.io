<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>http1.0&amp;http2.0 | 规矩之内,皆是自由</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">http1.0&amp;http2.0</h1><a id="logo" href="/.">规矩之内,皆是自由</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">http1.0&amp;http2.0</h1><div class="post-meta">Feb 23, 2020<span> | </span><span class="category"><a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h1 id="一、http1-x"><a href="#一、http1-x" class="headerlink" title="一、http1.x"></a>一、http1.x</h1><p>http1.x 的解析是基于文本</p>
<h2 id="1、http1-0"><a href="#1、http1-0" class="headerlink" title="1、http1.0"></a>1、http1.0</h2><p>HTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br>TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0 版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>
<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的 Connection 字段：</p>
<blockquote>
<p>Connection: keep-alive</p>
</blockquote>
<p>这个字段要求服务器不要关闭 TCP 连接，以便其他请求复用。</p>
<p>服务器同样回应这个字段：</p>
<blockquote>
<p>Connection: keep-alive</p>
</blockquote>
<p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h2 id="2、http1-1"><a href="#2、http1-1" class="headerlink" title="2、http1.1"></a>2、http1.1</h2><h3 id="2-1、持久化连接"><a href="#2-1、持久化连接" class="headerlink" title="2.1、持久化连接"></a>2.1、持久化连接</h3><p><strong>1.1 版的最大变化，就是引入了持久连接（persistent connection）</strong>，即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。<br>不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>目前，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。</p>
<h3 id="2-2、管道机制"><a href="#2-2、管道机制" class="headerlink" title="2.2、管道机制"></a>2.2、管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，<strong>完成后</strong>再回应 B 请求。</p>
<h3 id="2-3、Content-Length-字段"><a href="#2-3、Content-Length-字段" class="headerlink" title="2.3、Content-Length 字段"></a>2.3、Content-Length 字段</h3><p>一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是 Content-length 字段的作用，声明本次回应的数据长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure>

<p>上面代码告诉浏览器，本次回应的长度是 3495 个字节，后面的字节就属于下一个回应了。在 1.0 版中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了。</p>
<h3 id="2-4、分块传输编码"><a href="#2-4、分块传输编码" class="headerlink" title="2.4、分块传输编码"></a>2.4、分块传输编码</h3><p>使用 Content-Length 字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。<br>因此，1.1 版规定可以不使用 Content-Length 字段，而使用”分块传输编码”（chunked transfer encoding）。</p>
<p><strong>只要请求或回应的头信息有 Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>

<p>每个非空的数据块之前，会有一个 16 进制的数值，表示这个块的长度。最后是一个大小为 0 的块，就表示本次回应的数据发送完了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="2-5、其它功能"><a href="#2-5、其它功能" class="headerlink" title="2.5、其它功能"></a>2.5、其它功能</h3><p>1.1 版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。<br>另外，客户端请求的头信息新增了 Host 字段，用来指定服务器的域名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>

<p>有了 Host 字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h3 id="2-6、缺点"><a href="#2-6、缺点" class="headerlink" title="2.6、缺点"></a>2.6、缺点</h3><p>虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“<strong>队头堵塞</strong>”（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h1 id="二、http2-0"><a href="#二、http2-0" class="headerlink" title="二、http2.0"></a>二、http2.0</h1><p>http2.0 的前身是 SPDY 协议,2015 年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。<br>http2.0 的解析是基于二进制连接共享</p>
<h2 id="1、二进制协议"><a href="#1、二进制协议" class="headerlink" title="1、二进制协议"></a>1、二进制协议</h2><p>HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。<strong>HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制</strong>，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><img src="./http1-x-http-2-x/logo.jpg" alt="logo" style="zoom:50%;">

<ul>
<li>length: 定义了整个 frame 的开始到结束</li>
<li>type: frame 的类型（一共 10 种）,http1.x 的 header 和 body 部分用 frame 重新封装了一层</li>
<li>flags: bit 位定义一些重要的参数</li>
<li>stream id: 用作流控制, 连接共享使用</li>
<li>payload: request 的正文</li>
</ul>
<h2 id="2、多路复用"><a href="#2、多路复用" class="headerlink" title="2、多路复用"></a>2、多路复用</h2><p>HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了“队头堵塞”。</p>
<p>举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<p><strong>一个 TCP 链接有多个请求</strong></p>
<p>HTTP2 把要传输的信息分割成一个个二进制帧，首部信息会被封装到 HEADER Frame，相应的 request body 就放到 DATA Frame,一个帧你可以看成路上的一辆车,只要给这些车编号，让 1 号车都走 1 号门出，2 号车都走 2 号门出，就把不同的 http 请求或者响应区分开来了。但是，这里要求同一个请求或者响应的帧必须是有有序的，要保证 FIFO 的，但是不同的请求或者响应帧可以互相穿插。这就是 HTTP2 的多路复用，是不是充分利用了网络带宽</p>
<p>http1.1 建了 6 到 8 个 tcp 连接后，一个个请求串行地用这 6-8 个连接执行，而 http2 能一次把所有请求都发出去，还是压缩过的，高下立判。</p>
<h2 id="3、服务端推送-server-push"><a href="#3、服务端推送-server-push" class="headerlink" title="3、服务端推送(server push)"></a>3、服务端推送(server push)</h2><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做<strong>服务器推送</strong>（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<h2 id="4、数据流"><a href="#4、数据流" class="headerlink" title="4、数据流"></a>4、数据流</h2><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，<strong>客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数</strong>。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h2 id="4、头部压缩"><a href="#4、头部压缩" class="headerlink" title="4、头部压缩"></a>4、头部压缩</h2><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了<strong>头信息压缩机制</strong>（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/02/23/TCP-UDP/">TCP-UDP</a><a class="next" href="/2020/02/21/LVS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">LVS调度算法&amp;持久化连接</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJS/">NodeJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dev-ops/">dev&ops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lvs/">lvs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 15px;">内核</a> <a href="/tags/js-%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 15px;">js - 作用域</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/21/ts%E9%87%8D%E9%9A%BE%E7%82%B9%E6%A2%B3%E7%90%86/">ts重难点梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/js/">js重难点梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/tcp-ip%E8%AF%A6%E8%A7%A3-%E6%A6%82%E8%BF%B0/">tcp/ip详解-概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">mysql-存储引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/MFS-%E5%85%A5%E9%97%A8/">MFS-入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/01/Node%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/">Node面试总结1</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/%E6%B5%85%E8%B0%88NodeJS/">浅谈NodeJS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/28/redis%E9%87%8D%E9%9A%BE%E7%82%B9%E6%A2%B3%E7%90%86/">redis 重难点梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/lvs-nat/">lvs-nat</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/lvs-dr-keepalived/">lvs-dr-keepalived</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>